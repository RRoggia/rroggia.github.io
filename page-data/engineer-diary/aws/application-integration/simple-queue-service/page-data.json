{
    "componentChunkName": "component---src-templates-file-template-js",
    "path": "/engineer-diary/aws/application-integration/simple-queue-service",
    "result": {"pageContext":{"parentPath":"/engineer-diary/aws/application-integration/simple-queue-service","fileAbsolutePath":"/home/runner/work/rroggia.github.io/rroggia.github.io/content/engineer-diary/AWS/application-integration/simple-queue-service.md","html":"<p><a href=\"https://docs.aws.amazon.com/sqs/index.html\">Documentation</a></p>\n<h2>Overview</h2>\n<p>SQS is a regional fully managed queue service commonly used to integrate distributed systems in a decoupled, highly available and highly durable manner. It's a public service, therefore, it's possible to access from anywhere where you have access to the AWS public space.</p>\n<h2>Core Concept</h2>\n<p>The main core concept of SQS are the queues. It supports two types of <strong>Queues</strong>:</p>\n<ul>\n<li><strong>FIFO</strong>: The messages are <strong>delivered exactly once</strong> using the First In, First Out as the <strong>ordering mechanism</strong>. However, it has a limit of 3000 messages per second. Its performance is reduced due to the order and delivery guarantees. It supports up to 300 messages per second or using batch (10 events in a message) 3000 messages. Queues require the <strong>.fifo</strong> suffix.</li>\n<li><strong>Standard</strong>: Best effort ordering mechanism (<strong>order is not guaranteed</strong>), and a message is delivered <strong>at least once</strong> (potentially more times).</li>\n</ul>\n<p>Once you create the queue you can't change its type.</p>\n<h3>Sending a message</h3>\n<p>The queue receive events through the SQS <code>sendMessage</code> or <code>sendMessageBatch</code> API. The <strong>message size</strong> can be up to 256 KB for a single message or in the Batch API the number of message times the maximum message size. </p>\n<h3>Storing a message and handling its lyfecicle</h3>\n<p>A message remains in the queue until it is deleted, is moved or expires. Messages expire when reach the maximum <strong>retention period</strong>. It can range between 1 minute to 14 days. To move a message you configure a <strong>Redrive policy</strong> to send undeliverable messages (could not be processed after up to 1000 attempts or expired messages) to a <strong>Dead Letter Queue (DLQ)</strong>. The Redrive policy specifies the source queue, the DLQ where the message is going to be moved and the number of times a consumer attempts to process a message (<code>maxReceiveCount</code>).</p>\n<p>DLQ are used to handle the lifecycle of unconsumed messages . By default, all queues can be used as DLQ. However, the source and DLQ must have the same type both standard or both FIFO). You can also enable the <strong>Redrive allow policy</strong> in a queue to detail the source queues you want to allow or deny sources queues to move messages to the queue.</p>\n<p>A queue can have a <strong>Delivery Delay</strong> of up to 15 minutes, these are called delay queues. When the message arrives it starts to count the delay time, while the message is within the delay time it's not visible to the consumers to retrieve it. If you configure a delay to an existing queue there are two different behaviors depending on the queue type.</p>\n<ul>\n<li>Standard: The delay do not applies retroactively on messages</li>\n<li>FIFO: The delay do not applies retroactively on messages.</li>\n</ul>\n<p>Standard queues also support <strong>Message Timers</strong>, which enable to send per message delivery delay by specifying the <code>DelaySeconds</code> in the <code>sendMessage</code> or <code>sendMessageBatch</code> API.</p>\n<h3>Reading a message</h3>\n<p>To read messages from the queue you can use the <code>receiveMessage</code> API. There is two options to consume this API that vary depending on the queue's attribute <strong>Receive Message Wait time</strong> or the SDK.</p>\n<ul>\n<li><strong>Short pooling</strong>: When no <code>WaitTimeSeconds</code> is specified or equals to <code>0</code>. The default behavior. Sends the response right away from a subset of all distributed servers. You might receive empty responses even though there are messages to be consumed.</li>\n<li><strong>Long poling</strong>: When the <code>WaitTimeSeconds</code> is between <code>1</code> and <code>20</code>. SQS sends the response after it can find all the messages before the time elapses or returns the messages it got when the specified time elapses.</li>\n</ul>\n<p>Long pooling is a cheaper approach because it reduces the number of false empty responses and the number of HTTP requests.</p>\n<p>The <code>receiveMessage</code> response returns the messages from the queue to process that requested it, the process needs to send a <code>deleteMessage</code> or <code>deleteMessageBatch</code> to acknowledge the queue the message was processed and should be deleted. The <strong>Visibility Timeout</strong> configuration specifies the time the message is going to be hidden in the queue once it's returned in the <code>receiveMessage</code>, the process has the visibility timeout time to send the delete request with the message <strong>Receipt Id</strong>, otherwise, the message is visible again in the queue.</p>\n<p>When a Redrive policy is configured for the queue, each time the message is received the <code>receiveCountAttribute</code> is increased, when it reaches the maximum attempts it moves the message to the DLQ. When the message is moved to the DLQ its enqueue time, which is used to compute its expiration continues the same, therefore, you want the DLQ retention period to be higher than the source queue's retention period.</p>\n<h1>TODO</h1>\n<ul>\n<li>ASG can scale based on queue size</li>\n<li>Lambdas can be triggered by messages in queue</li>\n<li>SNS send to SQS</li>\n</ul>","frontmatter":{"title":"SQS - Simple Queue Service"},"isFile":true,"fileName":"simple-queue-service"}},
    "staticQueryHashes": ["1507822185","2095566405","2894216461","425755332"]}