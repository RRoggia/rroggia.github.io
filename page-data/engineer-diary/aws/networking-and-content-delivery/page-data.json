{
    "componentChunkName": "component---src-templates-folder-template-js",
    "path": "/engineer-diary/aws/networking-and-content-delivery",
    "result": {"pageContext":{"parentPath":"/engineer-diary/aws/networking-and-content-delivery","files":[{"fileAbsolutePath":"/home/runner/work/rroggia.github.io/rroggia.github.io/content/engineer-diary/AWS/networking-and-content-delivery/api-gateway.md","html":"<p><a href=\"https://docs.aws.amazon.com/apigateway/latest/developerguide/welcome.html\">Documentation</a></p>\n<p>Demo:</p>\n<ul>\n<li><a href=\"https://github.com/RRoggia/aws-workloads/tree/main/api-gateway\">Rest API</a></li>\n</ul>\n<h2>Overview</h2>\n<p>API Gateway is a region based AWS Service that allows you to manage your APIs.</p>\n<h2>Core Concepts</h2>\n<p>API Gateway supports three types of APIs:</p>\n<ul>\n<li><strong>Rest API</strong></li>\n<li><strong>HTTP</strong></li>\n<li><strong>WebSocket</strong></li>\n</ul>\n<h3>Rest API</h3>\n<p>Your Rest API exposes a collection of <strong>Resources</strong>, a representation of your business entities. A Resource has a <strong>Path</strong> and its possible to attach documentation to it. A resource can have multiple <strong>Methods</strong>, each method defines one possible interface used to access that resource. Each method specifies one of the HTTP Verb (GET, POST, ...) as a <strong>Method Type</strong>.</p>\n<p>A method has two components a <strong>Method Request</strong> and a <strong>Method Response</strong>. The Method Request defines the resource's interface by specifying the required or expected <strong>URL Query String Parameters</strong>, <strong>Request Headers</strong> and <strong>Request Body</strong>. You can also add a <strong>Authorization</strong> or configure the method to require an API key, in addition you can configure a <strong>Request Validator</strong>, which can validate query, headers and body.</p>\n<p>The method also contains information about the <strong>Integration</strong> between the Method and a backend service, which can be AWS services, services running within or outside AWS or even a Mock. Similar to the Method an integration is also composed by a Request and a Response.</p>\n<p>When the API Gateway receives an HTTP requesting a resource, it follows the following steps:</p>\n<ol>\n<li>Method Request</li>\n<li>Integration Request</li>\n<li>Integration Response</li>\n<li>Method Response</li>\n</ol>\n<p>When using <strong>Mock Integration</strong> configure both the <strong>Integration Request</strong> with a <strong>Template Model</strong> containing a status code and the <strong>Integration Response</strong> with the mock data.</p>\n<p>When using the <strong>AWS_PROXY</strong> Integration you can configure the API Gateway to send the an event object to the service being requested. The AWS service can then use this data to process and return a response. Using this integration API Gateway might require permissions to access the AWS Service they are trying to reach.</p>\n<p>It's also possible to setup an <strong>HTTP_PROXY</strong> integration, in which you configure the service URL and ports, this is useful for services running outside AWS. When API Gateway receives requests it sends the Integration request as configured and waits it response to send it back to the API Gateway's client.</p>\n<p>API Gateway also supports <strong>AWS</strong> and <strong>HTTP</strong> integrations. Both can be used when you want to do more than only proxying the requests, for example, providing data transformation.</p>\n<p>In order to make the API available for the end users you have to create a <strong>Deployment</strong>, which acts like a point in time for all your resources. The Deployments is made to a <strong>Stage</strong> which could act as an environment, you can have several Stages and each stage can contain several deployments. In a Stage you can configure which is the active deployment, and configure deployment strategies for new deployments. Other functionalities like Cache, Logging and tracing are also available per Stage.</p>\n<h1>Todo</h1>\n<ul>\n<li class=\"task-list-item\">\n<p><input type=\"checkbox\" disabled> Rest API</p>\n<ul>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled> Endpoint:</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled> Public and private Rest APIs regional, edge?</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled> default is edge</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled> Usage plans</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled> API Keys</li>\n</ul>\n</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled> HTTP API</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled> WebSocket API</li>\n</ul>","frontmatter":{"title":"API Gateway"},"isFile":true,"fileName":"api-gateway"},{"fileAbsolutePath":"/home/runner/work/rroggia.github.io/rroggia.github.io/content/engineer-diary/AWS/networking-and-content-delivery/route53.md","html":"<h2>Overview</h2>\n<p>Route 53 is a global service fully managed by AWS that offers domain registration and domain hosting. It's globally resilient, so it take all the regions to fail to have downtime.</p>\n<h2>Core concepts</h2>\n<p>R3 offers Domains Name Service, translates domains to IP addresses. You can create <strong>Hosted zones</strong> on R53. A Hosted zones is a DNS database for a domain.  It stores <strong>records</strong> and make them available in 4 <strong>name servers</strong>. Public hosted zones determine how traffic is routed in the internet. Private determine how traffic is routed within a VPC.</p>\n<p>AWS Supports all the DNS Record types, and in addition it allows you to use <strong>Aliases</strong>, which map to an AWS Resource.</p>\n<p>Route 53 <strong>Resolver</strong> is the default DNS server that responds to DNS queries from AWS resources. In a VPC the resolver runs in one of the reserved IP addresses VPC+2 IP address.</p>\n<p>You can use Route 53 only as domain registrar, only as a domain host or both. Because, it's very well integrated with AWS it works best when being used at least only as domain host. In addition, it's possible to use R53 to implement DNSSEC.</p>\n<p>R53 also offers <strong>health checks</strong> that are located globally and trigger every 30 seconds, with support to several protocols like TCP, HTTP and HTTPS. It can be used to monitor endpoints, CloudWatch alarms and checks of checks (calculated).</p>\n<p>Route 53 supports several types of routing:</p>\n<ul>\n<li><strong>Simple Routing</strong>: You create one Record per Name that returns multiple values. Values are returned in random order, the client chooses which to use. Do not support Health checks.</li>\n<li><strong>Failover Routing</strong>: You can create multiple Records for the same name. For each record you need to choose whether it's <strong>primary or secondary</strong>. Route 53 applies health checks on the primary record, if it fails, changes traffic to secondary record. It's a form of <strong>Active/Passive</strong> failvoer.</li>\n<li><strong>Multi Value Routing</strong>: Allows multiple records with same name. Each record can have <strong>multiple values</strong>. Health checks run for each value of the  record. It only returns the records that are healthy. Chooses up to 8 healthy records randomly to return to client, the client chooses which to use.</li>\n<li><strong>Weighted Routing</strong>: Allows multiple records with same name. Each records has a <strong>weight</strong>. The traffic is distributed to the records based on the record's weight divided by the sum all weights for a given name. Weight 0 is never returned, unless all records have the 0 weight. The health checks run after the evaluation, if the record chosen is not healthy, the process repeats.</li>\n<li><strong>Latency Routing</strong>: Allows multiple records with same name, each record specifies determines <strong>a region</strong>. DNS stores tables with source and destination and <strong>estimated latencies</strong>. Based on the table chooses the record with lowest latency. If lowest latency is unhealthy, the process repeats.</li>\n<li><strong>GeoLocation Routing</strong>: Allows multiple records with same name, each record specifies a Location like US States, countries, continent or the default. It only returns the <strong>records relevant</strong> to the source. Starts evaluating the State, Country, Continent and the default option at last. If no records match, no answers is returned. It can be used to deliver content or services to a specific location or to specify resources over regional endpoints. If most specific resource is unhealthy, the process repeats.</li>\n<li><strong>GeoProximity Routing</strong>: Allows multiple records with same name, each record is tagged with an AWS Region or latitude and longitude coordinates for external resources. The <strong>actual distance</strong> between the customer and the record is used to determine the record. However, you can add <strong>biases</strong> to increase or decrease the geographic region size.</li>\n</ul>","frontmatter":{"title":"Route 53"},"isFile":true,"fileName":"route53"},{"fileAbsolutePath":"/home/runner/work/rroggia.github.io/rroggia.github.io/content/engineer-diary/AWS/networking-and-content-delivery/virtual-private-cloud.md","html":"<p><a href=\"https://docs.aws.amazon.com/vpc/latest/userguide/what-is-amazon-vpc.html\">Documentation</a></p>\n<h2>Overview</h2>\n<p>AWS VPC is an AWS fully managed service that provides regional isolated virtual networks. You can use VPCs to run EC2 instances, RDS databases, and several other AWS services. VPC is one of the core services of AWS.</p>\n<h2>Core Concepts</h2>\n<p>A <strong>Virtual Private Cloud</strong> is an isolated virtual network. It has a range of IP address denoted using the CIDR block and is associated to a specific region. VPCs must have a IPv4 range, and optionally a IPv6 range. A VPC  has a minimum CIDR block of /28 and maximum of /16.</p>\n<p>Within a VPC you can create <strong>subnets</strong>, a range of IP address which are a subset of the VPC's IPs. Subnets reside on availability zones, spanning multiple subnets across AZs is one of the steps to achieve High Availability on AWS. In addition, you should also use subnets to isolate different tiers of your infrastructure. A subnet can be either public or private. <strong>Public Subnet</strong> has internet connectivity while <strong>Private Subnets</strong> cannot be accessed from the internet.</p>\n<p>There are two types of VPC Default and Nondefault (Custom). The difference from the Default VPC and Custom VPCS is that each component of a custom VPC must be explicitly defined when you create it.</p>\n<ul>\n<li>Nondefault (Custom): Created and customized by you.</li>\n<li>Default: Created and customized by AWS.</li>\n</ul>\n<p>The <strong>Default VPC</strong> is automatically created by AWS. You'll have 1 default VPC in each region of your account. They all follow the same configuration. It uses the 172.31.0.0/16 as the IPv4 range and it comes with internet connectivity configured. It also spans one subnet for each AZ supported in that region. It's not a good practice to use the default VPC for production.</p>\n<p>When you create a VPC, it creates a DHCP option set, a Main route table, a Main Network ACL and a default security group.</p>\n<p>The Dynamic Host Configuration Protocol, or DHCP for short, assings IP addresses dinamically to devices in the VPC. Usually you'll have one <strong>DHCP option set</strong> by region. However you can configure others.</p>\n<p><strong>Route tables</strong> are composed of routes that determine the network traffic of your subnets. The <strong>Main route table</strong>, is a route table that comes with the VPC. The main route is the default route for all subnets, but, you can create and associate route table to the subnets. All subnets must have at least one route table. One route table can be used by several subnets.</p>\n<p>The <strong>Routes</strong> created in the route table are composed by a <strong>destination</strong> and a <strong>target</strong>. The destination, is where you want the traffic to go and the target the connection through which to send it. By default, resources within subnets will be able to communicate because of a route that matches traffic to the VPC IP Range.</p>\n<p>A subnet with a route table that contains a route with destination to the internet and target to an <strong>Internet Gateway</strong> is considered a public subnet. To enable only the subnet to initiate traffic to the internet configure a route table to destinate traffic to the internet and target to <strong>NAT Gateway</strong>. The NAT Gateway must be in a public subnet.</p>\n<p>The <strong>VPC router</strong> uses these route tables to determine the traffic. The VPC router runs in all AZs of a region. In case of conflicting rules, the most specific rule applies. The highest the prefix of the IP range the more specific it is. After the router sends the traffic to the destination The <strong>Network Access Control List</strong>, <strong>NACL</strong>, determines which traffic is allowed or denied to enter the subnets.</p>\n<p>NACL is a firewall that operates on the subnet level. The Main NACL associated with a VPC is the default NACL associated to subnets. You can create new NACL and associate to the subnets. By default, the Main NACL is configured to allow traffic in (inbound) and out (outbound) of the subnets. However, if you create a custom NACL its default behavior is to deny all traffic. NACL is considered <strong>stateless</strong> because packages are validated against its rules when entering and leaving the subnets.</p>\n<p>NACL contains a number of rules that are evaluated by their priority, the role number. A rule also specifies a protocol, a port range, an IP range and if the rule allows or denies the traffic matching its configuration.</p>\n<p>Because NACL only applies to communication that enters or leaves a subnet. It does not apply to resources within a subnet. To secure resources within a subnet we use <strong>Security Groups</strong>. A security group is also a firewall but operates at resource level. It controls the traffic that is allowed in and out of the resource. A security group is considered <strong>stateful</strong>, therefore, if the resource is initiating the traffic it will only check the outbound rules, and if the resource is receiving traffic it will check the inbound rules.</p>\n<p>By default security groups deny all traffic, you need to explicitly specify which traffic is allowed. It's not possible to explicitly specify rules to deny traffic. The Default security group is associated with the VPC and any resource within the VPC that you don't explicitly specify a security group. It's inbound rules allows all traffic from IPv4 and IPv6 resources that are also secured by the default security group. The outbound rules allows all traffic to the internet. </p>\n<p>One distinction of the security group rules to NACL rules is that you can specify logical AWS resources, like other security groups, in the rules. It's also important to notice SG are not attached to the resource itself but to the Elastic Network Interface(ENI) of a resource.</p>\n<p>Best practices to secure VPCs are to use both NACL and SGs. Be strict allowing only the required traffic. And limit the access to changing the rules for only authorized persons.</p>","frontmatter":{"title":"VPC - Virtual Private Cloud"},"isFile":true,"fileName":"virtual-private-cloud"}],"folders":[]}},
    "staticQueryHashes": ["1507822185","2095566405","2894216461","425755332"]}