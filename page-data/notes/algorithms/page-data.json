{"componentChunkName":"component---src-templates-note-template-js","path":"/notes/algorithms","result":{"data":{"markdownRemark":{"frontmatter":{"title":"Algorithms","date":"2022-05-09","published":null,"tags":null},"tableOfContents":"<ul>\n<li>\n<p><a href=\"#one---fundamentals\">One - Fundamentals</a></p>\n<ul>\n<li><a href=\"#11-basic-programming-model\">1.1 Basic Programming Model</a></li>\n<li><a href=\"#12-data-abstraction\">1.2 Data Abstraction</a></li>\n<li>\n<p><a href=\"#13-bags-queues-and-stacks\">1.3 Bags, Queues and Stacks</a></p>\n<ul>\n<li><a href=\"#bags\">Bags</a></li>\n<li><a href=\"#fifo-queues\">FIFO queues</a></li>\n<li><a href=\"#pushdown-stacks\">Pushdown stacks</a></li>\n<li><a href=\"#loitering\">Loitering</a></li>\n<li><a href=\"#linked-lists\">Linked lists</a></li>\n</ul>\n</li>\n<li><a href=\"#14-analysis-of-algorithms\">1.4 Analysis of Algorithms</a></li>\n<li><a href=\"#15-case-study-union-find\">1.5 Case Study: Union-Find</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#two---sorting\">Two - Sorting</a></p>\n<ul>\n<li>\n<p><a href=\"#21-elementary-sorts\">2.1 Elementary Sorts</a></p>\n<ul>\n<li><a href=\"#selection-sort\">Selection Sort</a></li>\n<li><a href=\"#insertion-sort\">Insertion Sort</a></li>\n<li><a href=\"#shell-sort\">Shell Sort</a></li>\n</ul>\n</li>\n<li><a href=\"#22-mergesort\">2.2 Mergesort</a></li>\n<li><a href=\"#23-quicksort\">2.3 Quicksort</a></li>\n<li>\n<p><a href=\"#24-priority-queues\">2.4 Priority Queues</a></p>\n<ul>\n<li><a href=\"#heapsort\">Heapsort</a></li>\n</ul>\n</li>\n<li><a href=\"#25-applications\">2.5 Applications</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#three---searching\">Three - Searching</a></p>\n<ul>\n<li><a href=\"#31-symbol-tables\">3.1 Symbol Tables</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#four---graphs\">Four - Graphs</a></p>\n<ul>\n<li><a href=\"#41-undirected-graphs\">4.1 Undirected Graphs</a></li>\n</ul>\n</li>\n</ul>","html":"<h1>One - Fundamentals</h1>\n<h2>1.1 Basic Programming Model</h2>\n<blockquote>\n<p>The basis of our approach is the scientific method: we develop hypotheses about performance, create mathematical models, and run experiments to test them, repeating the process as necessary.</p>\n</blockquote>\n<blockquote>\n<p>The term algorithm is used in computer science to describe a finite, deterministic, and effective problem-solving method suitable for implementation as a computer program</p>\n</blockquote>\n<blockquote>\n<p>When developing a huge or complex computer program, a great deal of effort must go into understanding and defining the problem to be solved, managing its complexity, and decomposing it into smaller subtasks that can be implemented easily.</p>\n</blockquote>\n<blockquote>\n<p>We should not use an algorithm without having an idea of what resources it might consume, so we strive to be aware of how our algorithms might be expected to perform.</p>\n</blockquote>\n<blockquote>\n<p>There are three important rules of thumb in developing recursive programs:</p>\n<ul>\n<li>The recursion has a base case—we always include a conditional statement as the first statement in the program that has a return.</li>\n<li>Recursive calls must address subproblems that are smaller in some sense, so that recursive calls converge to the base case. In the code below, the difference between the values of the fourth and the third arguments always decreases.</li>\n<li>Recursive calls should not address subproblems that overlap. In the code below, the portions of the array referenced by the two subproblems are disjoint.</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>The purpose of an API is to separate the client from the implementation: the client should know nothing about the implementation other than information given in the API, and the implementation should not take properties of any particular client into account. </p>\n</blockquote>\n<blockquote>\n<p>Accordingly, programmers normally think of the API as a contract between the client and the implementation that is a clear specification of what each method is to do. Our goal when developing an implementation is to honor the terms of the contract. </p>\n</blockquote>\n<h2>1.2 Data Abstraction</h2>\n<blockquote>\n<p>The primary difference is that we associate data with the function implementations and we hide the representation of the data from the client.</p>\n</blockquote>\n<blockquote>\n<p>Objects are characterized by three essential properties: state, identity, and behavior.</p>\n</blockquote>\n<blockquote>\n<p>Java nomenclature makes clear the distinction from primitive types (where variables are associated with values) by using the term reference types for nonprimitive types.</p>\n</blockquote>\n<blockquote>\n<p>This situation is known as aliasing: both variables refer to the same object.</p>\n</blockquote>\n<blockquote>\n<p>In other words, the convention is to pass the reference by value (make a copy of it) but to pass the object by reference.</p>\n</blockquote>\n<blockquote>\n<p>A data type is a set of values and a set of operations defined on those values. We implement data types in independent Java class modules and write client programs that use them</p>\n</blockquote>\n<blockquote>\n<p>An object is an entity that can take on a data-type value or an instance of a data type.</p>\n</blockquote>\n<blockquote>\n<p>Whenever you have data of different types that logically belong together, it is worthwhile to contemplate defining an ADT as in these examples.</p>\n</blockquote>\n<blockquote>\n<ul>\n<li>Specify an API. The purpose of the API is to separate clients from implementations, to enable modular programming. We have two goals when specifying an API. First, we want to enable clear and correct client code. Indeed, it is a good idea to write some client code before finalizing the API to gain confidence that the specified data-type operations are the ones that clients need. Second, we want to be able to implement the operations. There is no point specifying operations that we have no idea how to implement.</li>\n<li>Implement a Java class that meets the API specifications. First we choose the instance variables, then we write constructors and the instance methods.</li>\n<li>Develop multiple test clients, to validate the design decisions made in the first two steps.</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>Encapsulation enables modular programming, allowing us to</p>\n<ul>\n<li>Independently develop of client and implementation code</li>\n<li>Substitute improved implementations without affecting clients</li>\n<li>Support programs not yet written (the API is a guide for any future client)</li>\n</ul>\n<p> Encapsulation also isolates data-type operations, which leads to the possibility of</p>\n<ul>\n<li>Limiting the potential for error</li>\n<li>Adding consistency checks and other debugging tools in implementations</li>\n<li>Clarifying client code</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>We do so by insisting on the API being the only point of dependence between client and implementation</p>\n</blockquote>\n<blockquote>\n<p>You do not need to know how a data type is implemented in order to use it and you can assume that a client knows nothing but the API when implementing a data type</p>\n</blockquote>\n<blockquote>\n<p>Articulating an API might seem to be overkill when writing a small program, but you should consider writing every program as though you will need to reuse the code someday</p>\n</blockquote>\n<blockquote>\n<p>Within this broad outline, there are numerous pitfalls that every API design is susceptible to:</p>\n<ul>\n<li>An API may be too hard to implement, implying implementations that are difficult or impossible to develop.</li>\n<li>An API may be too hard to use, leading to client code that is more complicated than it would be without the API.</li>\n<li>An API may be too narrow, omitting methods that clients need.</li>\n<li>An API may be too wide, including a large number of methods not needed by any client. This pitfall is perhaps the most common, and one of the most difficult to avoid. The size of an API tends to grow over time because it is not difficult to add methods to an existing API, but it is difficult to remove methods without breaking existing clients.</li>\n<li>An API may be too general, providing no useful abstractions.</li>\n<li>An API may be too specific, providing abstractions so detailed or so diffuse as to be useless.</li>\n<li>An API may be too dependent on a particular representation, therefore not serving the purpose of freeing client code from the details of using that representation. This pitfall is also difficult to avoid, because the representation is certainly central to the development of the implementation.</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>Generally, immutable types are easier to use and harder to misuse than mutable types because the scope of code that can change their values is far smaller.</p>\n</blockquote>\n<blockquote>\n<p>The downside of immutability is that a new object must be created for every value</p>\n</blockquote>\n<blockquote>\n<p>Another downside of immutability stems from the fact that, unfortunately, final guarantees immutability only when instance variables are primitive types, not reference types</p>\n</blockquote>\n<blockquote>\n<p>Assertions are for debugging: your program should not rely on assertions for normal operation since they may be disabled</p>\n</blockquote>\n<blockquote>\n<p>The designer of a data type expresses a precondition (the condition that the client promises to satisfy when calling a method), a postcondition (the condition that the implementation promises to achieve when returning from a method), and side effects (any other change in state that the method could cause). During development, these conditions can be tested with assertions. </p>\n</blockquote>\n<blockquote>\n<p>Subtyping makes modular programming more difficult for two reasons. First, any change in the superclass affects all subclasses. The subclass cannot be developed independently of the superclass; indeed, it is completely dependent on the superclass. This problem is known as the fragile base class problem.</p>\n</blockquote>\n<h2>1.3 Bags, Queues and Stacks</h2>\n<h3>Bags</h3>\n<blockquote>\n<p>A bag is a collection where removing items is not supported—its purpose is to provide clients with the ability to collect items and then to iterate through the collected items (the client can also test if a bag is empty and find its number of items).</p>\n</blockquote>\n<blockquote>\n<p>The order of iteration is unspecified and should be immaterial to the client.</p>\n</blockquote>\n<h3>FIFO queues</h3>\n<blockquote>\n<p>A FIFO queue (or just a queue) is a collection that is based on the firstin-first-out (FIFO) policy</p>\n</blockquote>\n<blockquote>\n<p>A typical reason to use a queue in an application is to save items in a collection while at the same time preserving their relative order : they come out in the same order in which they were put in.</p>\n</blockquote>\n<h3>Pushdown stacks</h3>\n<blockquote>\n<p>A pushdown stack (or just a stack) is a collection that is based on the last-in-first-out (LIFO) policy.</p>\n</blockquote>\n<h3>Loitering</h3>\n<blockquote>\n<p>Java’s garbage collection policy is to reclaim the memory associated with any objects that can no longer be accessed.</p>\n</blockquote>\n<blockquote>\n<p>This condition (holding a reference to an item that is no longer needed) is known as loitering</p>\n</blockquote>\n<blockquote>\n<p>performance goals for any collection implementation:</p>\n<ul>\n<li>Each operation should require time independent of the collection size.</li>\n<li>The space used should always be within a constant factor of the collection size.</li>\n</ul>\n</blockquote>\n<h3>Linked lists</h3>\n<blockquote>\n<p>A linked list is a recursive data structure that is either empty (null) or a reference to a node having a generic item and a reference to a linked list. </p>\n</blockquote>\n<blockquote>\n<p>The node in this definition is an abstract entity that might hold any kind of data, in addition to the node reference that characterizes its role in building linked lists.</p>\n</blockquote>\n<blockquote>\n<p>To emphasize that we are just using the Node class to structure the data, we define no methods and we refer directly to the instance variables in code: if first is a variable associated with an object of type Node, we can refer to the instance variables with the code first.item and first.next. Classes of this kind are sometimes called records.</p>\n</blockquote>\n<blockquote>\n<p>The standard solution to enable arbitrary insertions and deletions is to use a doubly-linked list, where each node has two links, one in each direction.</p>\n</blockquote>\n<blockquote>\n<p>(To go through the linked list elements) This process is known as traversing the list</p>\n</blockquote>\n<blockquote>\n<p>This implementation uses the same data structure as does Stack—a linked list—but it implements different algorithms for adding and removing items, which make the difference between LIFO and FIFO for the client. </p>\n</blockquote>\n<blockquote>\n<p>Linked lists are a fundamental alternative to arrays for structuring a collection of data</p>\n</blockquote>\n<blockquote>\n<p>These two alternatives, often referred to as sequential allocation and linked allocation, are fundamental.</p>\n</blockquote>\n<h2>1.4 Analysis of Algorithms</h2>\n<blockquote>\n<p>One of the key tenets of the scientific method is that the experiments we design must be reproducible, so that others can convince themselves of the validity of the hypothesis. Hypotheses must also be falsifiable, so that we can know for sure when a given hypothesis is wrong (and thus needs revision). As Einstein famously is reported to have said (“No amount of experimentation can ever prove me right; a single experiment can prove me wrong”), we can never know for sure that any hypothesis is absolutely correct; we can only validate that it is consistent with our observations.</p>\n</blockquote>\n<blockquote>\n<p>Our first qualitative observation about most programs is that there is a problem size that characterizes the difficulty of the computational task</p>\n</blockquote>\n<blockquote>\n<p>Intuitively, the running time should increase with problem size, but the question of by how much it increases naturally comes up every time we develop and run a program</p>\n</blockquote>\n<blockquote>\n<p>Knuth’s basic insight is simple: the total running time of a program is determined by two primary factors:</p>\n<ul>\n<li>The cost of executing each statement</li>\n<li>The frequency of execution of each statement</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>To allow us to ignore insignificant terms and therefore substantially simplify the mathematical formulas that we work with, we often use a mathematical device known as the tilde notation (~).</p>\n</blockquote>\n<blockquote>\n<p>This notation allows us to work with tilde approximations, where we throw away low-order terms that complicate formulas and represent a negligible contribution to values of interest</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>description</th>\n<th>function</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>constant</td>\n<td>1</td>\n</tr>\n<tr>\n<td>logarithmic</td>\n<td>log N</td>\n</tr>\n<tr>\n<td>linear</td>\n<td>N</td>\n</tr>\n<tr>\n<td>linearithmic</td>\n<td>N log N</td>\n</tr>\n<tr>\n<td>quadratic</td>\n<td>N^2</td>\n</tr>\n<tr>\n<td>cubic</td>\n<td>N^3</td>\n</tr>\n<tr>\n<td>exponential</td>\n<td>2^N</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>A key observation from this exercise is to note that only the instructions that are executed the most frequently play a role in the final total—we refer to these instructions as the inner loop of the program.</p>\n</blockquote>\n<blockquote>\n<p>The algorithm that you are using (and sometimes the input model) determines the order of growth. Separating the algorithm from the implementation on a particular computer is a powerful concept because it allows us to develop knowledge about the performance of algorithms and then apply that knowledge to any computer.</p>\n</blockquote>\n<blockquote>\n<ul>\n<li>Develop an input model, including a definition of the problem size.</li>\n<li>Identify the inner loop.</li>\n<li>Define a cost model that includes operations in the inner loop.</li>\n<li>Determine the frequency of execution of those operations for the given input</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>As it turns out, several important problems have natural solutions that are quadratic but clever algorithms that are linearithmic</p>\n</blockquote>\n<blockquote>\n<p>Typical computer systems are extremely complex and close analysis is best left for experts, but the same methods are effective for developing approximate estimates of the running time of any program.</p>\n</blockquote>\n<blockquote>\n<p>These guarantees are not absolute, but the chance that they are invalid is less than the chance your computer will be struck by lightning. Thus, such guarantees are as useful in practice as worst-case guarantees.</p>\n</blockquote>\n<blockquote>\n<p>when your program calls a method, the system allocates the memory needed for the method (for its local variables) from a special area of memory called the stack (a system pushdown stack), and when the method returns to the caller, the memory is returned to the stack</p>\n</blockquote>\n<blockquote>\n<p>When you create an object with new, the system allocates the memory needed for the object from another special area of memory known as the heap (not the same as the binary heap data structure we consider in Section 2.4), and you must remember that every object lives until no references to it remain, at which point a system process known as garbage collection reclaims its memory for the heap</p>\n</blockquote>\n<blockquote>\n<p>Perhaps the most common mistake made in programming is to pay too much attention to performance characteristics. Your first priority is to make your code clear and correct</p>\n</blockquote>\n<h2>1.5 Case Study: Union-Find</h2>\n<blockquote>\n<p>The size of a tree is its number of nodes. The depth of a node in a tree is the number of links on the path from it to the root. The height of a tree is the maximum depth among its nodes. </p>\n</blockquote>\n<h1>Two - Sorting</h1>\n<h2>2.1 Elementary Sorts</h2>\n<blockquote>\n<p>Sorting cost model. When studying sorting algorithms, we count compares and exchanges. For algorithms that do not use exchanges, we count array accesses.</p>\n</blockquote>\n<blockquote>\n<p>The sorting algorithms divide into two basic types: those that sort in place and use no extra memory except perhaps for a small function call stack or a constant number of instance variables, and those that need enough extra memory to hold another copy of the array to be sorted.</p>\n</blockquote>\n<h3>Selection Sort</h3>\n<blockquote>\n<p><strong>Selection sort.</strong> One of the simplest sorting algorithms works as follows: First, find the smallest item in the array and exchange it with the first entry (itself if the first entry is already the smallest). Then, find the next smallest item and exchange it with the second entry. Continue in this way until the entire array is sorted. This method is called selection sort because it works by repeatedly selecting the smallest remaining item.</p>\n</blockquote>\n<blockquote>\n<p>For example, the person using the sort client might be surprised to realize that it takes about as long to run selection sort for an array that is already in order or for an array with all keys equal as it does for a randomly-ordered array!</p>\n</blockquote>\n<h3>Insertion Sort</h3>\n<blockquote>\n<p><strong>Insertion sort</strong> The algorithm that people often use to sort bridge hands is to consider the cards one at a time, inserting each into its proper place among those already considered (keeping them sorted).</p>\n</blockquote>\n<blockquote>\n<p>consider what happens when you use insertion sort on an array that is already sorted. Each item is immediately determined to be in its proper place in the array, and the total running time is linear. </p>\n</blockquote>\n<blockquote>\n<p>If the number of inversions in an array is less than a constant multiple of the array size, we say that the array is partially sorted</p>\n</blockquote>\n<blockquote>\n<p>Indeed, when the number of inversions is low, insertion sort is likely to be faster than any sorting method that we consider in this chapter.</p>\n</blockquote>\n<blockquote>\n<p>In summary, insertion sort is an excellent method for partially sorted arrays and is also a fine method for tiny arrays</p>\n</blockquote>\n<h3>Shell Sort</h3>\n<blockquote>\n<p><strong>Shellsort</strong> is a simple extension of insertion sort that gains speed by allowing exchanges of array entries that are far apart, to produce partially sorted arrays that can be efficiently sorted, eventually by insertion sort.</p>\n</blockquote>\n<blockquote>\n<p>The idea is to rearrange the array to give it the property that taking every <em>h</em>th entry (starting anywhere) yields a sorted subsequence. Such an array is  said to be h-sorted. Put another way, an h-sorted array is h independent sorted subsequences, interleaved together.</p>\n</blockquote>\n<blockquote>\n<p>achieving speedups that enable the solution of problems that could not otherwise be solved is one of the prime reasons to study algorithm performance and design.</p>\n</blockquote>\n<h2>2.2 Mergesort</h2>\n<blockquote>\n<p>combining two ordered arrays to make one larger ordered array.</p>\n</blockquote>\n<blockquote>\n<p>to sort an array, divide it into two halves, sort the two halves (recursively), and then merge the results.</p>\n</blockquote>\n<blockquote>\n<p>most attractive properties is that it guarantees to sort any array of N items in time proportional to N log N. Its prime disadvantage is that it uses extra space proportional to N.</p>\n</blockquote>\n<blockquote>\n<p>In the merge, there are four conditions:</p>\n<ul>\n<li>left half exhausted (take from the right),</li>\n<li>right half exhausted (take from the left),</li>\n<li>current key on right less than current key on left (take from the right),</li>\n<li>current key on right greater than or equal to current key on left (take from the left).</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>The tree has precisely n levels.</p>\n</blockquote>\n<blockquote>\n<p>If space is at a premium, we need to consider another method.</p>\n</blockquote>\n<blockquote>\n<p>When addressing a new problem, your best bet is to use the simplest implementation with which you are comfortable and then refine it if it becomes a bottleneck.</p>\n</blockquote>\n<h2>2.3 Quicksort</h2>\n<blockquote>\n<p>The quicksort algorithm’s desirable features are that it is in-place (uses only a small auxiliary stack) and that it requires time proportional to N log N on the average to sort an array of length N.</p>\n</blockquote>\n<blockquote>\n<p>Quicksort is complementary to mergesort: for mergesort, we break the array into two subarrays to be sorted and then combine the ordered subarrays to make the whole ordered array; for quicksort, we rearrange the array such that, when the two subarrays are sorted, the whole array is ordered.</p>\n</blockquote>\n<blockquote>\n<p>Ultimately, the efficiency of the sort depends on how well the partitioning divides the array, which in turn depends on the value of the partitioning item’s key.</p>\n</blockquote>\n<blockquote>\n<p>The best case for quicksort is when each partitioning stage divides the array exactly in half.</p>\n</blockquote>\n<blockquote>\n<p>it can be extremely inefficient if the partitions are unbalanced</p>\n</blockquote>\n<blockquote>\n<p>Quicksort is slower than insertion sort for tiny subarrays.</p>\n</blockquote>\n<blockquote>\n<p>( Improving quicksort) It turns out that most of the available improvement comes from choosing a sample of size 3 and then partitioning on the middle item</p>\n</blockquote>\n<blockquote>\n<p>It was a classical programming exercise popularized by E. W. Dijkstra as the Dutch National Flag problem, because it is like sorting an array with three possible key values, which might correspond to the three colors on the flag.</p>\n</blockquote>\n<blockquote>\n<p>A carefully tuned version of quicksort is likely to run significantly faster on most computers for most applications than will any other compare-based sorting method.</p>\n</blockquote>\n<h2>2.4 Priority Queues</h2>\n<blockquote>\n<p>(computer running several apps) This effect is typically achieved by assigning a priority to events associated with applications, then always choosing to process next the highest-priority event.</p>\n</blockquote>\n<blockquote>\n<p>An appropriate data type in such an environment supports two operations: remove the maximum and insert. Such a data type is called a priority queue.</p>\n</blockquote>\n<blockquote>\n<p>Some important applications of priority queues include simulation systems, where the keys correspond to event times, to be processed in chronological order; job scheduling, where the keys correspond to priorities indicating which tasks are to be performed first; and numerical computations, where the keys represent computational errors, indicating in which order we should deal with them</p>\n</blockquote>\n<blockquote>\n<p>We can use any priority queue as the basis for a sorting algorithm by inserting a sequence of items, then successively removing the smallest to get them out, in order.</p>\n</blockquote>\n<blockquote>\n<p>Using <strong>unordered sequences</strong> is the prototypical lazy approach to this problem, where we defer doing work until necessary (to find the maximum);</p>\n</blockquote>\n<blockquote>\n<p>Using <strong>ordered sequences</strong> is the prototypical eager approach to the problem, where we do as much work as we can up front (keep the list sorted on insertion) to make later operations efficient.</p>\n</blockquote>\n<blockquote>\n<p>For stacks and queues, we were able to develop implementations of all the operations that take constant time; for priority queues, all of the elementary implementations just discussed have the property that either the insert or the remove the maximum operation takes linear time in the worst case. The heap data structure that we consider next enables implementations where both operations are guaranteed to be fast.</p>\n</blockquote>\n<blockquote>\n<p>A binary tree is <strong>heap-ordered</strong> if the key in each node is larger than or equal to the keys in that node’s two children (if any).</p>\n</blockquote>\n<blockquote>\n<p>(<strong>Complete binary tree</strong>) We draw such a structure by placing the root node and then proceeding down the page and from left to right,\ndrawing and connecting two nodes beneath each node on the previous level until we have drawn N nodes.</p>\n</blockquote>\n<blockquote>\n<p>A <strong>binary heap</strong> is a collection of keys arranged in a complete heap-ordered binary tree, represented in level order in an array (not using the first entry).</p>\n</blockquote>\n<blockquote>\n<p>In a heap, the parent of the node in position k is in position ⎣k /2⎦ and, conversely, the two children of the node in position k are in positions 2k and 2k + 1.</p>\n</blockquote>\n<blockquote>\n<p>Complete binary trees represented as arrays (heaps) are rigid structures, but they have just enough flexibility to allow us to implement efficient priority-queue operations.</p>\n</blockquote>\n<blockquote>\n<p>(Travel up or down to restore the heap order) We refer to this process as <strong>reheapifying</strong>, or <strong>restoring heap order</strong></p>\n</blockquote>\n<blockquote>\n<p>Where elementary implementations using an ordered array or an unordered array require linear time for one of the operations, a heap-based implementation provides a guarantee that both operations complete in logarithmic time.</p>\n</blockquote>\n<blockquote>\n<p>(Multiway heaps) There is a tradeoff between the lower cost from the reduced tree height (log d N) and the higher cost of finding the largest of the <strong>d</strong> children at each node</p>\n</blockquote>\n<blockquote>\n<p>Immutability of keys. The priority queue contains objects that are created by clients but assumes that client code does not change the keys (which might invalidate the heap-order invariant)</p>\n</blockquote>\n<h3>Heapsort</h3>\n<blockquote>\n<p>We can use any priority queue to develop a sorting method. We insert all the items to be sorted into a minimum-oriented priority queue, then repeatedly use remove the minimum to remove them all in order.</p>\n</blockquote>\n<blockquote>\n<p>Using a priority queue represented as an unordered array in this way corresponds to doing a selection sort; using an ordered array corresponds to doing an insertion sort.</p>\n</blockquote>\n<blockquote>\n<p>Heapsort breaks into two phases: heap construction, where we reorganize the original array into a heap, and the sortdown, where we pull the items out of the heap in decreasing order to build the sorted result.</p>\n</blockquote>\n<blockquote>\n<p>This process is a bit like selection sort (taking the items in decreasing order instead of in increasing order), but it uses many fewer compares because the heap provides a much more efficient way to find the largest item in the unsorted part of the array.</p>\n</blockquote>\n<blockquote>\n<p>Although the loops in this program seem to do different tasks (the first constructs the heap, and the second destroys the heap for the sortdown), they are both built around the sink() method.</p>\n</blockquote>\n<blockquote>\n<p>Heapsort is significant in the study of the complexity of sorting (see page 279) because it is the only method that we have seen that is optimal (within a constant factor) in its use of both time and space—it is guaranteed to use ~2N lg N compares and constant extra space in the worst case.</p>\n</blockquote>\n<h2>2.5 Applications</h2>\n<blockquote>\n<p>It stands to reason that an array might not remain sorted if a client is allowed to change the values of keys after the sort.</p>\n</blockquote>\n<blockquote>\n<p>The reference approach makes the cost of an exchange roughly equal to the cost of a compare for general situations involving arbitrarily large items (at the cost of the extra space for the references).</p>\n</blockquote>\n<blockquote>\n<p>The Java Comparator interface allows us to build multiple orders within a single class. It has a single public method compare() that compares two objects.</p>\n</blockquote>\n<blockquote>\n<p>A sorting method is stable if it preserves the relative order of equal keys in the array. ... To begin, suppose that we store events in an array as they arrive, so they are in order of the timestamp in the array. Now suppose that the application requires that the transactions be separated out by location for further processing. One easy way to do so is to sort the array by location. If the sort is unstable, the transactions for each city may not necessarily be in order by timestamp after the sort.</p>\n</blockquote>\n<blockquote>\n<p>Some of the sorting methods that we have considered in this chapter are stable (insertion sort and mergesort); many are not (selection sort, shellsort, quicksort, and heapsort).</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>algorithm</th>\n<th>stable?</th>\n<th>running time</th>\n<th>extra space</th>\n<th>notes</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>selection sort</td>\n<td>no</td>\n<td>N²</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>insertion sort</td>\n<td>yes</td>\n<td>between N and N²</td>\n<td>1</td>\n<td>depends on order of items</td>\n</tr>\n<tr>\n<td>shellsort</td>\n<td>no</td>\n<td>N log N / N ^ 6/5</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>quicksort</td>\n<td>no</td>\n<td>N log N</td>\n<td>lg N</td>\n<td>probabilistic guarantee</td>\n</tr>\n<tr>\n<td>3-way quicksort</td>\n<td>no</td>\n<td>between N and N log N</td>\n<td>lg N</td>\n<td>probabilistic, also depends on distribution of input keys</td>\n</tr>\n<tr>\n<td>mergesort</td>\n<td>yes</td>\n<td>N log N</td>\n<td>N</td>\n<td></td>\n</tr>\n<tr>\n<td>heapsort</td>\n<td>no</td>\n<td>N log N</td>\n<td>1</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>Perhaps the best way to interpret Property T is as saying that you certainly should seriously consider using quicksort in any sort application where running time is important.</p>\n</blockquote>\n<blockquote>\n<p>Java’s systems programmers have chosen to use quicksort (with 3-way partitioning) to implement the primitive-type methods, and mergesort for reference-type methods. The primary practical implications of these choices are, as just discussed, to trade speed and memory usage (for primitive types) for stability (for reference types).</p>\n</blockquote>\n<blockquote>\n<p>A reduction is a situation where an algorithm developed for one problem is used to solve another.</p>\n</blockquote>\n<blockquote>\n<p>(Duplicates) first sort the array, then make a pass through the sorted array, taking note of duplicate keys that appear consecutively in the ordered array.</p>\n</blockquote>\n<blockquote>\n<p>An effective alternative to TopM when you have the items in an array is to just smallest values in the array are in the first k array positions for all k less than the array length.</p>\n</blockquote>\n<blockquote>\n<p>(Data sorted) You will also see that the same scheme makes it easy to quickly handle many other kinds of queries. How many items are smaller than a given item? Which items fall within a given range?</p>\n</blockquote>\n<h1>Three - Searching</h1>\n<blockquote>\n<p> We use the term <strong>symbol table</strong> to describe an abstract mechanism where we save information (a value) that we can later search for and retrieve by specifying a key.</p>\n</blockquote>\n<blockquote>\n<p>Symbol tables are sometimes called dictionaries, by analogy with the time-honored system of providing definitions for words by listing them alphabetically in a reference book.</p>\n</blockquote>\n<h2>3.1 Symbol Tables</h2>\n<blockquote>\n<p>A <strong>symbol table</strong> is a data structure for key-value pairs that supports two operations: insert (put) a new pair into the table and search for (get) the value associated with a given key.</p>\n</blockquote>\n<blockquote>\n<p>These conventions define the associative array abstraction, where you can think of a symbol table as being just like an array, where keys are indices and values are array entries.</p>\n</blockquote>\n<h1>Four - Graphs</h1>\n<h2>4.1 Undirected Graphs</h2>\n<blockquote>\n<p>A <strong>graph</strong> is a set of vertices and a collection of edges that each connect a pair of vertices.</p>\n</blockquote>\n<blockquote>\n<p>Our definition allows two simple anomalies:</p>\n<ul>\n<li>A self-loop is an edge that connects a vertex to itself.</li>\n<li>Two edges that connect the same pair of vertices are parallel.</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>When there is an edge connecting two vertices, we say that the vertices are <em>adjacent</em> to one another and that the edge is <em>incident</em> to both vertices.</p>\n</blockquote>\n<blockquote>\n<p>The <strong>degree</strong> of a vertex is the number of edges incident to it.</p>\n</blockquote>\n<blockquote>\n<p>A <strong>path</strong> in a graph is a sequence of vertices connected by edges</p>\n</blockquote>\n<blockquote>\n<p>A <strong>simple path</strong> is one with no repeated vertices.</p>\n</blockquote>\n<blockquote>\n<p>A <strong>cycle</strong> is a path with at least one edge whose first and last vertices are the same.</p>\n</blockquote>\n<blockquote>\n<p>when we want to allow repeated vertices, we refer to general paths and cycles.</p>\n</blockquote>\n<blockquote>\n<p>A <strong>graph is connected</strong> if there is a path from every vertex to every other vertex in the graph. A <strong>graph that is not connected</strong> consists of a set of connected components, which are maximal connected subgraphs.</p>\n</blockquote>\n<blockquote>\n<p>An <strong>acyclic</strong> graph is a graph with no cycles.</p>\n</blockquote>\n<blockquote>\n<p>A <strong>tree</strong> is an acyclic connected graph.</p>\n</blockquote>\n<blockquote>\n<p>A <strong>spanning tree</strong> of a connected graph is a subgraph that contains all of that graph’s vertices and is a single tree.</p>\n</blockquote>\n<blockquote>\n<p>A disjoint set of trees is called a <strong>forest</strong>.</p>\n</blockquote>\n<blockquote>\n<p>For example, a graph G with V vertices is a tree if and only if it satisfies any of the following five conditions:</p>\n<ul>\n<li>G has V1 edges and no cycles.</li>\n<li>G has V1 edges and is connected.</li>\n<li>G is connected, but removing any edge disconnects it.</li>\n<li>G is acyclic, but adding any edge creates a cycle.</li>\n<li>Exactly one simple path connects each pair of vertices in G.</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>A <strong>sparse</strong> graph has relatively few of the possible edges present; a <strong>dense</strong> graph has relatively few of the possible edges missing.</p>\n</blockquote>\n<blockquote>\n<p>A <strong>bipartite</strong> graph is a graph whose vertices we can divide into two sets such that all edges connect a vertex in one set with a vertex in the other set.</p>\n</blockquote>\n<blockquote>\n<p>An adjacency matrix, where we maintain a V-by-V boolean array, with the entry in row v and column w defined to be true if there is an edge adjacent to both vertex v and vertex w in the graph, and to be false otherwise.</p>\n</blockquote>\n<blockquote>\n<p>An array of edges, using an Edge class representations with two instance variables of type int.</p>\n</blockquote>\n<blockquote>\n<p>An array of adjacency lists, where we maintain a vertex-indexed array of lists of the vertices adjacent to each vertex.</p>\n</blockquote>\n<blockquote>\n<p><strong>Tremaux exploration</strong>. To explore all passages in a maze:</p>\n<ul>\n<li>Take any unmarked passage, unrolling a string behind you.</li>\n<li>Mark all intersections and passages when you first visit them.</li>\n<li>Retrace steps (using the string) when approaching a marked intersection.</li>\n<li>Retrace steps when no unvisited options remain at an intersection encountered while retracing steps.</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>To visit a vertex:</p>\n<ul>\n<li>Mark it as having been visited.</li>\n<li>Visit (recursively) all the vertices that are adjacent to it and that have not yet been marked.</li>\n</ul>\n<p>This method is called <strong>depth-first search (DFS)</strong></p>\n</blockquote>\n<blockquote>\n<p>in DFS of an undirected graph, we either do a recursive drawing with both edges call when we encounter an edge v-w (if w is not marked) or skip the edge (if w is marked)</p>\n</blockquote>\n<blockquote>\n<p><strong>Connectivity</strong>. Given a graph, support queries of the form Are two given vertices connected ? and How many connected components does the graph have ?</p>\n</blockquote>\n<blockquote>\n<p><strong>Single-source paths</strong>. Given a graph and a source vertex s, support queries of the form Is there a path from s to a given target vertex v? If so, find such a path.</p>\n</blockquote>\n<blockquote>\n<p><strong>Single-source shortest paths.</strong> Given a graph and a source vertex s, support queries of the form Is there a path from s to a given target vertex v? If so, find a shortest such path (one with a minimal number of edges).</p>\n</blockquote>\n<blockquote>\n<p>DFS is analogous to one person exploring a maze. BFS is analogous to a group of searchers exploring by fanning out in all directions, each unrolling his or her own ball of string. When more than one passage needs to be explored, we imagine that the searchers split up to expore all of them;</p>\n</blockquote>\n<blockquote>\n<p>We put the source vertex on the data structure, then perform the following steps until the data structure is empty:</p>\n<ul>\n<li>Take the next vertex v from the data structure and mark it.</li>\n<li>Put onto the data structure all unmarked vertices that are adjacent to v.</li>\n</ul>\n<p>The algorithms differ only in the rule used to take the next vertex from the data structure (least recently added for BFS, most recently added for DFS).</p>\n</blockquote>\n<blockquote>\n<p><strong>Cycle detection.</strong> Support this query: Is a given graph acylic ?</p>\n</blockquote>\n<blockquote>\n<p><strong>Two-colorability.</strong> Support this query: Can the vertices of a given graph be assigned one of two colors in such a way that no edge connects vertices of the same color ? which is equivalent to this question: Is the graph bipartite ?</p>\n</blockquote>\n<blockquote>\n<p><strong>Symbol graphs</strong>. Typical applications involve processing graphs defined in files or on web pages, using strings, not integer indices, to define and refer to vertices.</p>\n</blockquote>"}},"pageContext":{"title":"Algorithms"}},"staticQueryHashes":["1507822185","2095566405","2894216461","425755332"]}