{"componentChunkName":"component---src-templates-note-template-js","path":"/notes/rfc7521---assertion-framework-for-oauth-2.0-client-authentication-and-authorization-grants","result":{"data":{"markdownRemark":{"frontmatter":{"title":"RFC7521 - Assertion Framework for OAuth 2.0 Client Authentication and Authorization Grants","date":"2018-06-01","published":null,"tags":null},"tableOfContents":"<ul>\n<li><a href=\"#abstract\">Abstract</a></li>\n<li><a href=\"#1-introduction\">1. Introduction</a></li>\n<li><a href=\"#2-notational-conventions\">2. Notational Conventions</a></li>\n<li><a href=\"#3-framework\">3. Framework</a></li>\n<li>\n<p><a href=\"#4-transporting-assertions\">4. Transporting Assertions</a></p>\n<ul>\n<li>\n<p><a href=\"#41-using-assertions-as-authorization-grants\">4.1. Using assertions as Authorization Grants</a></p>\n<ul>\n<li><a href=\"#411-error-response\">4.1.1. Error Response</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#42-using-assertions-for-client-authentication\">4.2 Using Assertions for Client Authentication</a></p>\n<ul>\n<li><a href=\"#421-error-response\">4.2.1. Error Response</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#5-assertion-content-and-processing\">5. Assertion Content and Processing</a></p>\n<ul>\n<li>\n<p><a href=\"#51-assertion-metamodel\">5.1. Assertion Metamodel</a></p>\n<ul>\n<li><a href=\"#issuer\">Issuer</a></li>\n<li><a href=\"#subject\">Subject</a></li>\n<li><a href=\"#audience\">Audience</a></li>\n<li><a href=\"#issued-at\">Issued At</a></li>\n<li><a href=\"#expires-at\">Expires At</a></li>\n<li><a href=\"#assertion-id\">Assertion ID</a></li>\n</ul>\n</li>\n<li><a href=\"#52-general-assertion-format-and-processing-rules\">5.2. General Assertion Format and Processing Rules</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#6-common-scenarios\">6. Common Scenarios</a></p>\n<ul>\n<li><a href=\"#61-client-authentication\">6.1. Client Authentication</a></li>\n<li><a href=\"#62-client-acting-on-behalf-of-itself\">6.2. Client Acting on Behalf of Itself</a></li>\n<li>\n<p><a href=\"#63-client-acting-on-behalf-of-a-user\">6.3. Client Acting on Behalf of a User</a></p>\n<ul>\n<li><a href=\"#631-client-acting-on-behalf-of-an-anonymous-user\">6.3.1. Client Acting on Behalf of an Anonymous User</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#7-interoperability-considerations\">7. Interoperability Considerations</a></li>\n<li>\n<p><a href=\"#8-security-considerations\">8. Security Considerations</a></p>\n<ul>\n<li><a href=\"#81-forged-assertion\">8.1. Forged Assertion</a></li>\n<li><a href=\"#82-stolen-assertion\">8.2. Stolen Assertion</a></li>\n<li><a href=\"#83-unauthorized-disclosure-of-personal-information\">8.3. Unauthorized Disclosure of Personal Information</a></li>\n<li><a href=\"#84-privacy-considerations\">8.4. Privacy Considerations</a></li>\n</ul>\n</li>\n<li><a href=\"#9-iana-considerations\">9. IANA Considerations</a></li>\n</ul>","html":"<p><a href=\"https://tools.ietf.org/html/rfc7521\">RFC7521 - Assertion Framework for OAuth 2.0 Client Authentication and Authorization Grants</a></p>\n<h1>Abstract</h1>\n<blockquote>\n<p>[...] provides a framework for the use of assertions with OAuth 2.0 in the form of a new client authentication mechanism and a new authorization grant type.</p>\n</blockquote>\n<blockquote>\n<p>[...] to provide a common framework for OAuth 2.0 to interwork with other identity systems using assertions and to provide alternative client authentication mechanism.</p>\n</blockquote>\n<h1>1. Introduction</h1>\n<blockquote>\n<p>An assertion is a package of information that facilitates the sharing of identity and security information across security domains.</p>\n</blockquote>\n<p>This specification provides two functionalities:</p>\n<ul>\n<li>a framework that uses packages of informations (assertions) as a credential representing the resource owner's authorization (authorization grant) with OAuth 2.0.</li>\n<li>a framework for assertions to be used for client authentication.</li>\n</ul>\n<p>You'll also find:</p>\n<blockquote>\n<p>[...] generic mechanisms for transporting assertions during interactions with an authorization server's token endpoint</p>\n</blockquote>\n<blockquote>\n<p>[...] general rules for the content and processing of those assertions.</p>\n</blockquote>\n<p>The intent behind adding this two functionalities are two:</p>\n<ul>\n<li>Alternative client authentication mechanism (one that doesn't send client secrets).</li>\n<li>Facilitate the use of OAuth 2.0 in client-server integration scenarios, where the end user may not be present.</li>\n</ul>\n<p>Using the assertions as authorization grant is separable from using the assertion from client authentication. Each functionality can be used on its own.</p>\n<blockquote>\n<p>Client assertion authentication is nothing more than an alternative way for a client to authenticate to the token endpoint.</p>\n</blockquote>\n<h1>2. Notational Conventions</h1>\n<p>Uses keywords as decribed in RFC 2119.</p>\n<h1>3. Framework</h1>\n<p>An assertion typically contains:</p>\n<ul>\n<li>information about a subject or principal</li>\n<li>information about the party that issued it</li>\n<li>when it was issued </li>\n<li>under which conditions the assertion is to be considered valid</li>\n</ul>\n<p>The entity that creates and signs or integrity-protects it is know as the \"Issuer\".</p>\n<p>The entity that consumes the assertion is known the \"Relying party\". In the context of this document, the authorization server acts as a Relying party.</p>\n<p>The issuer must protect the integrity of an assertion by applying a digital signature or a Message Authentication Code (MAC). Its intent is to identify the issuer and ensure the assertion's content integrity.</p>\n<p>In addition, an assertion might be encrypted.</p>\n<p>The specification doesn't define how the Client obtains the assertion, but it suggests two main ways:</p>\n<ol>\n<li>Assertion created by a third party</li>\n</ol>\n<p>The Client obtains an assertion from a third-party entity capable of issuing, renewing, transforming, and validating security tokens. This entity is known as \"security token service\" (STS) or just \"token service\". </p>\n<p>A trust relationship exists between the STS and the relying party (authorization service).</p>\n<ol start=\"2\">\n<li>Self issued assertion</li>\n</ol>\n<p>The Client creates assertions locally.</p>\n<p>Self-issued assertions can be used to demonstrate knowledge of some secret, such as a Client secret, without actually communicating the secret directly in the transaction.</p>\n<p>In the point of view of the entity presenting the assertion, there are two types of assertion:</p>\n<ol>\n<li>Bearer Assertion: Any entity in possession of a bearer assertion (the bearer) can use it to get access to the associated resources (without demonstrating possession of a cryptographic key)</li>\n<li>Holder-of-key Assertion: To access the associated resources, the entity presenting the assertion must demonstrate possession of additional cryptographic material. The STS thereby binds a key identifier to the assertion, and the Client has to demonstrate to the Relying Party knowledge about it.</li>\n</ol>\n<p>The scope of this specification only covers a Client presenting a bearer assertion to an authorization server.</p>\n<h1>4. Transporting Assertions</h1>\n<p>Is mandatory to use HTTPS.</p>\n<h2>4.1. Using assertions as Authorization Grants</h2>\n<p>When using assertions as authorization grants, the client includes the assertion and related information using the following HTTP request parameters:</p>\n<ul>\n<li><code>grant_type</code>: REQUIRED. The format of the assertion.</li>\n<li><code>assertion</code>: REQUIRED. The assertion being used as an authorization grant.</li>\n<li><code>scope</code>: OPTIONAL. The request scope must be equal or less than the scope originally granted to the authorized accessor.</li>\n</ul>\n<p>The authentication of the client is optional. Therefore, <code>client_id</code> is only required when the client authentication relies on this parameter.</p>\n<p>Example:</p>\n<pre><code>POST /token HTTP/1.1\nHost: server.example.com\nContent-Type: application/x-www-form-urlencoded\n\ngrant_type=urn:ietf:params:oauth:grant-type:saml2-bearer&#x26;\nassertion={assertion-goes-here}\n</code></pre>\n<p>An assertion used in this context is a short lived representation of the authorization grant. The access token issued by authorization server should not have a lifespan way bigger than its assertion validity.</p>\n<h3>4.1.1. Error Response</h3>\n<p>If an assertion is not valid or has expired the value of the <code>error</code> parameter must be the <code>invalid_grant</code>.</p>\n<h2>4.2 Using Assertions for Client Authentication</h2>\n<p>When using assertions as client credentials, the client includes the assertion and related information using the following HTTP request parameters:</p>\n<ul>\n<li><code>client_assertion_type</code>: REQUIRED. The format of the assertion.</li>\n<li><code>client_assertion</code>: REQUIRED. The assertion being used to authenticate the client.</li>\n<li><code>client_id</code>: OPTIONAL. It's unnecessary, the client is already identified by the subject of the assertion. If specified, it must be the same as identified by the client assertion.</li>\n</ul>\n<p>Example:</p>\n<pre><code>POST /token HTTP/1.1\nHost: server.example.com\nContent-Type: application/x-www-form-urlencoded\n\ngrant_type=authorization_code&#x26;\ncode={{authorization_code_goes_here}}&#x26;\nclient_assertion_type=urn:ietf:params:oauth:client-assertion-type:saml2-bearer&#x26;\nclient_assertion={client_assertion-goes-here}\n</code></pre>\n<h3>4.2.1. Error Response</h3>\n<p>If an assertion is invalid for any reason or if more than one client authentication mechanism is used the value of the <code>error</code> parameter must be the <code>invalid_client</code>.</p>\n<h1>5. Assertion Content and Processing</h1>\n<p>Provides general content and processing model for the use of assertions with OAuth 2.0.</p>\n<h2>5.1. Assertion Metamodel</h2>\n<p>The following are general terms abstract from any particular assertion format.</p>\n<h3>Issuer</h3>\n<p>A unique identifier for the entity that issued the assertion. It holds the key material used to sign or integrity-protect the assertion. OAuth Clients (self-issued assertions) and STS are examples.</p>\n<h3>Subject</h3>\n<p>A unique identifier for the principal that is the subject of the assertion. Two possible interpretations:</p>\n<ul>\n<li>Assertions during client authentication: Identifies the client to the authorization server using the value in the <code>client_id</code>.</li>\n<li>Assertions during authorization grant: Identifies an authorized accessor for which the access token is being requested.</li>\n</ul>\n<h3>Audience</h3>\n<p>Identifies the party or parties intended to process the assertion. The URL of the token endpoint can be used to indicate the authorization server as a valid intended audience.</p>\n<h3>Issued At</h3>\n<p>Time at which the assertion was issued. UTC format.</p>\n<h3>Expires At</h3>\n<p> Time at which the assertion expires. UTC format.</p>\n<h3>Assertion ID</h3>\n<p>An nonce or unique identifier for the assertion.</p>\n<h2>5.2. General Assertion Format and Processing Rules</h2>\n<p>The assertion must contain:</p>\n<ul>\n<li>Issuer</li>\n<li>Subject</li>\n<li>Audience: It must identify the authorization server as the intended audience.</li>\n<li>Expires At: Authorization server must reject assertions that are expired.</li>\n<li>Issued At</li>\n</ul>\n<h1>6. Common Scenarios</h1>\n<h2>6.1. Client Authentication</h2>\n<p>A client uses an assertion to authenticate to the authorization server's token endpoint (as described in 4.2).</p>\n<p>The assertion's Subject is the client.</p>\n<p>If it's a self-issued assertion the assertion's Issuer is also the client.</p>\n<h2>6.2. Client Acting on Behalf of Itself</h2>\n<p>A client is accessing resources on behalf of itself. Analogous to the Client Credentials Grant. It combines both the authentication an authorization grant usage patterns.</p>\n<p>The interaction with the authorization server is treated as using an assertion for Client authentication (as described in 4.2), while using the <code>client_credentials</code> as <code>grant_type</code> to indicate that the client is requesting an access token for itself.</p>\n<p>Example:</p>\n<pre><code>POST /token HTTP/1.1\nHost: server.example.com\nContent-Type: application/x-www-form-urlencoded\n\ngrant_type=client_credentials&#x26;\nclient_assertion_type=urn:ietf:params:oauth:client-assertion-type:saml2-bearer&#x26;\nclient_assertion={client_assertion-goes-here}\n</code></pre>\n<h2>6.3. Client Acting on Behalf of a User</h2>\n<p>A client is accessing a resource on behalf of a user. It has to inform the <code>assertion</code> as the <code>grant_type</code> parameter (as described in 4.1). The Subject identifies an authorized accessor, typically the resource owner or an authorized delegate.</p>\n<h3>6.3.1. Client Acting on Behalf of an Anonymous User</h3>\n<p>A client is accessing resources on behalf of an anonymous user. A mutually agree-upon Subject identifier indicating anonymity is used.</p>\n<p>Authorization may be based upon additional criteria, such as additional attributes or claims provided in the assertion.</p>\n<h1>7. Interoperability Considerations</h1>\n<blockquote>\n<p>On its own, this specification is not sufficient to produce interoperable implementations.</p>\n</blockquote>\n<p>The RFC 7522 and RFC 7523 specify additional details about assertions encoding and processing rules.</p>\n<p>Specific items that require agreement are:</p>\n<ul>\n<li>Values for the Issuer and Audience identifier</li>\n<li>Supported assertion and client authentication types</li>\n<li>The location of the token endpoint</li>\n<li>The key used to apply and verify the diginal signature or MAC over assertions</li>\n<li>Maximum assertion lifetime allowed</li>\n<li>Subject and attribute requirements </li>\n</ul>\n<h1>8. Security Considerations</h1>\n<h2>8.1. Forged Assertion</h2>\n<p>Threat: An adversary could forge or alter an assertion in order to obtain an acces token (as described in 4.1) or to impersonate a client (as described in 4.2).</p>\n<p>Countermeasure: Apply mechanisms for protecting the integrity of the assertion (digital signature or MAC).</p>\n<h2>8.2. Stolen Assertion</h2>\n<p>Threat: An adversary might obtain an assertion and then reuse it later in time.</p>\n<p>Countermeasure: Use secure communication channels with server authentication for all network exchanges.</p>\n<h2>8.3. Unauthorized Disclosure of Personal Information</h2>\n<p>Threat: Other entities to obtain information about an individual (role in an organization, authentication information, ...)</p>\n<p>Countermeasure: Use of TLS and encrypt assertion.</p>\n<h2>8.4. Privacy Considerations</h2>\n<p>An assertion may contain privacy-sensitive information, therefore, use TLS and encrypt this information.</p>\n<h1>9. IANA Considerations</h1>\n<p>Register of <code>assertion</code>, <code>client_assertion</code>, <code>client_assertion_type</code>.</p>"}},"pageContext":{"title":"RFC7521 - Assertion Framework for OAuth 2.0 Client Authentication and Authorization Grants"}},"staticQueryHashes":["1507822185","2095566405","2894216461","425755332"]}